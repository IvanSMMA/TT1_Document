\chapter{Pruebas}
\section{Pruebas del Modulo del Procesamiento de Lenguaje Natural (PLN)}

\vspace{1em}

\subsection{Metodología de testing}

{\large \noindent \textbf{Piramide de Testing}}

La estrategia de testing del proyecto sigue el modelo de la Pirámide de testing propuesta por Mike Cohn, que establece una distribución óptima de los diferentes tipos de pruebas.\\

\begin{center}
    \includegraphics[width=0.45\textwidth]{Images/Cap5/1_PiramideTesting.png}
    \captionof{figure}[Piramide de Testing]{Piramide de Testing, elaboración propia.} 
\end{center}

\noindent \textbf{Distribución implementada}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{4cm}|p{2.5cm}|p{2.5cm}|p{4cm}|}
\hline
\textbf{Tipo de test} & \textbf{Cantidad} & \textbf{\% Total} & \textbf{Tiempo de ejecución} \\ \hline
\textit{Tests} unitarios & 37 & 51\% & $<$5 segundos \\ \hline
\textit{Tests} integración & 10 & 14\% & $\sim$8 segundos \\ \hline
\textit{Tests} E2E & 26 & 35\% & $\sim$15 segundos \\ \hline
Total (núcleo) & 73 & 100\% & $\sim$28 segundos \\ \hline
\textit{Test} adicionales & 95 & - & Variable \\ \hline
Total general & 168 & - & - \\ \hline
\end{tabular}
\caption[Resumen de tests]{Resumen de tests, elaboración propia.}
\end{table}

\textbf{Nota:} Los tests de performance, quality y stress \textbf{NO} se incluyen en la distribución de la pirámide ya que son tests especializados que se ejecutan de forma independiente.\\

\noindent \textbf{Justificación del 35\% de tests E2E}

El porcentaje elevado de tests E2E (superior al estándar industrial de 10--15\%) se justifica por los requisitos específicos de sistemas PLN:

\begin{enumerate}
    \item Validación exhaustiva de robustez lingüística.
    \item Tests de tolerancia a errores ortográficos y variaciones naturales.
    \item Validación de casos edge específicos (nombres propios, leet speak).
    \item Degradación gradual ante inputs de baja calidad.
\end{enumerate}

{\large \noindent \textbf{Stack tecnológico}}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{4cm}|p{4cm}|p{3cm}|}
\hline
\textbf{Componente} & \textbf{Tecnología} & \textbf{Versión} \\ \hline
\textit{Framework de testing} & \textit{pytest} & 7.4+ \\ \hline
\textit{API testing} & FastAPI TestClient & 0.104+ \\ \hline
\textit{Cobertura de código} & pytest-cov & 4.1+ \\ \hline
\textit{Load testing} & Locust & 2.15+ \\ \hline
\textit{Performance benchmarks} & pytest-benchmark & 4.0+ \\ \hline
\textit{Resource monitoring} & psutil & 5.9+ \\ \hline
\end{tabular}
\caption[Tecnologías de testing]{Tecnologías usadas para testing, elaboración propia.}
\end{table}

{\large \noindent \textbf{Estructura del testing}}

El sistema de testing está organizado en directorios especializados:

\begin{verbatim}
tests/
|-- unit/                          # 37 tests unitarios
|   |-- test_matcher.py            # Matching semantico (25 tests)
|   `-- test_preprocess.py         # Preprocesamiento (12 tests)
|
|-- integration/                   # 10 tests de integracion
|   `-- test_api.py                # Endpoints FastAPI
|
|-- e2e/                           # 26 tests end-to-end
|   |-- test_scenarios.py          # Escenarios de usuario (8 tests)
|   |-- test_robustness.py         # Robustez linguistica (14 tests)
|   `-- test_casos_realistas.py    # Casos reales (4+ tests)
|
|-- quality/                       # Tests de calidad semantica
|   |-- test_semantic_quality.py
|   `-- test_semantic_advanced.py
|
`-- performance/                   # Tests de rendimiento
    |-- test_benchmarks.py
    |-- test_stress_concurrent.py
    `-- locustfile.py
\end{verbatim}

{\noindent \textbf{Estadísticas generales}}

\begin{itemize}
    \item Líneas de código de testing: 2{,}749.
    \item Funciones de test: 168.
    \item Cobertura de código: 90.8\%.
    \item Tiempo de ejecución: \textasciitilde 28 segundos.
\end{itemize}

{\large \noindent \textbf{Tests unitarios (37 tests, 89\% cobertura)}}

Los tests unitarios validan componentes individuales de forma aislada, constituyendo la base de la pirámide de testing.\\

\textbf{Tests del Matcher Semántico (25 tests)}

Componente central responsable de:

\begin{itemize}
    \item Generación de embeddings con modelos transformer.
    \item Cálculo de similitud coseno.
    \item Clasificación en grupos semánticos (A, B, C).
    \item Activación de modo deletreo.
\end{itemize}

\vspace{1em}

{\large \noindent \textbf{Casos críticos validados}}

\textbf{1. Normalización de similitud al rango [0.0, 1.0] (4 tests)}\\

Problema resuelto: El sistema original retornaba valores > 1.0 debido a errores de precisión flotante.\\

Solución implementada:

\begin{lstlisting}[language=Python]
def clip_similarity(similarity: float) -> float:
    """Normaliza similitud al rango [0.0, 1.0]."""
    if similarity > 1.0:
        return 1.0
    elif similarity < 0.0:
        return 0.0
    return similarity
\end{lstlisting}

Resultado: 100\% de tests garantizan similitud matemáticamente correcta.\\

\textbf{2. Validación de rango en todas las queries (6 tests)}\\

Test parametrizado con 10 queries diversas validando:

\begin{verbatim}
assert 0.0 <= result["similitud"] <= 1.0
\end{verbatim}

\textbf{3. Detección de patrones de nombres (7 tests)}\\

Funcionalidad especial que detecta y procesa:

\begin{itemize}
    \item "Me llamo [Nombre]"
    \item "Mi nombre es [Nombre]"
\end{itemize}

Ejemplo:

\begin{lstlisting}
Input:  "Me llamo Juan Carlos"

Output: {
    "nombre_detectado": true,
    "nombre_extraido": "Juan Carlos",
    "nombre_deletreado": ["J","U","A","N"," ","C","A","R","L","O","S"],
    "total_caracteres_nombre": 11
}
\end{lstlisting}

\textbf{4. Clasificación en grupos semánticos (3 tests)}\\

Grupos del sistema:

\begin{itemize}
    \item Grupo A: Emergencias (ayuda, socorro, urgente).
    \item Grupo B: Saludos (hola, buenos días, adios).
    \item Grupo C: Expresiones de mínima comunicación (gracias, sí, bien).
\end{itemize}

{\large \noindent \textbf{Tests de preprocesamiento (12 tests)}}\\

Validación de normalización de texto para robustez del sistema PLN:\\

\textbf{1. Normalización de texto (7 tests)}

Transformaciones aplicadas:

\begin{itemize}
    \item Conversión a minúsculas.
    \item Eliminación de acentos (Unicode normalization).
    \item Eliminación de caracteres especiales.
    \item Normalización de espacios múltiples.
\end{itemize}

Ejemplo:

\begin{verbatim}
"¡HOLA, ¿Cómo  estás?!" → "hola como estas"
\end{verbatim}

\textbf{Resultados}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{4cm}|p{3.5cm}|p{3.5cm}|}
\hline
\textbf{Métrica} & \textbf{Valor} & \textbf{Objetivo} \\ \hline
Total tests & 37 & 30+ \\ \hline
Tests exitosos & 37 (100\%) & 100\% \\ \hline
Cobertura de código & 89\% & $>$80\% \\ \hline
Tiempo de ejecución & $<$5 segundos & $<$10 segundos \\ \hline
Casos límite cubiertos & 15+ & 10+ \\ \hline
\end{tabular}
\caption[Métricas de tests]{Métricas principales de los tests, elaboración propia.}
\end{table}


\textbf{2. Deletreo con caracteres especiales (5 tests)}

Mapeo implementado:

\begin{verbatim}
@ → "arroba", . → "punto", ! → "exclamación", (espacio) → "espacio"
\end{verbatim}

{\large \noindent \textbf{Tests de integración (10 tests, 6 endpoints)}}\\

Validación de la interacción entre componentes y funcionamiento de la API REST.\\

\textbf{Endpoints testeados}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{5cm}|p{2.5cm}|p{3.5cm}|}
\hline
\textbf{Endpoint} & \textbf{Tests} & \textbf{Status Codes Validados} \\ \hline
POST /buscar & 8 & 200, 400, 422 \\ \hline
GET /grupos & 1 & 200 \\ \hline
GET /grupos/\{grupo\} & 2 & 200, 404 \\ \hline
POST /deletreo & 3 & 200, 400 \\ \hline
GET /health & 1 & 200 \\ \hline
GET / & 1 & 200 \\ \hline
\end{tabular}
\caption[Tests por endpoint]{Resumen de tests por endpoint, elaboración propia.}
\end{table}

\noindent \textbf{Casos críticos del Endpoint principal (POST /buscar)}

\begin{enumerate}
    \item Query válida retorna resultado correcto.
    \item Queries inválidas retornan errores apropiados (400, 422).
    \item Match exacto tiene similitud muy alta (>0.95).
    \item Queries sin match activan deletreo automático.
    \item Emergencias se clasifican correctamente en Grupo A.
    \item Caso edge ``Ivan'': detecta baja similitud y activa deletreo.
\end{enumerate}

\textbf{Problema histórico del caso \texttt{``Ivan''}}:

\begin{itemize}
    \item Antes: Se matcheaba incorrectamente con ``Sí'' (Grupo C).
    \item Ahora: Detecta baja similitud (<0.3) y activa deletreo.
    \item Resultado: Usuario recibe I-V-A-N.
\end{itemize}

\textbf{Resultados}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline
\textbf{Métrica} & \textbf{Valor} \\ \hline
Total tests & 10 \\ \hline
Tests exitosos & 10 (100\%) \\ \hline
Endpoints cubiertos & 6 \\ \hline
Tiempo de ejecución & $\sim$8s \\ \hline
\end{tabular}
\caption[Métricas adicionales]{Métricas adicionales de pruebas, elaboración propia.}
\end{table}

{\large \noindent \textbf{Tests End - To - End  y robustez lingüística (26 tests)}}\\
Los tests E2E validan robustez ante variaciones naturales del lenguaje mediante ``Perturbation Testing'', metodología específica para sistemas PLN.\\

\textbf{Escenarios completos de usuario (8 escenarios)}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{5cm}|p{2.5cm}|p{4cm}|}
\hline
\textbf{Escenario} & \textbf{Tests} & \textbf{Validación principal} \\ \hline
Emergencias & 2 & Clasificación Grupo A \\ \hline
Saludos formales & 3 & Tolerancia a variaciones \\ \hline
Casos edge & 3 & Manejo robusto (\texttt{"Ivan"}) \\ \hline
Conversación completa & 3 & Consistencia temporal \\ \hline
Múltiples usuarios & 2 & Estabilidad bajo carga \\ \hline
Salud del sistema & 2 & \textit{Health checks} \\ \hline
\end{tabular}
\caption[Escenarios de prueba]{Escenarios evaluados, cantidad de tests y validación principal, elaboración propia.}
\end{table}

\textbf{Tests de robustez lingüística (14 tests) - crítico PLN}\\
Metodología de ``Perturbation Testing'' con 4 estrategias

\begin{enumerate}
    \item Character-level perturbations (errores de tipeo).
    \item Input fuzzing (ruido en el input).
    \item Semantic equivalence testing (sinónimos).
    \item Load testing (estrés).
\end{enumerate}

\textbf{Tipos de perturbaciones testeadas (50+ casos)}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{5.5cm}|p{6cm}|}
\hline
\textbf{Tipo de perturbación} & \textbf{Ejemplos} \\ \hline
Errores al inicio & \texttt{``hola''} → \texttt{``hila''} \\ \hline
Errores en medio & \texttt{``ayuda''} → \texttt{``auuda''} \\ \hline
Errores al final & \texttt{``hola''} → \texttt{``holq''} \\ \hline
Carácter faltante & \texttt{``hola''} → \texttt{``hla''} \\ \hline
Carácter extra & \texttt{``hola''} → \texttt{``hoola''} \\ \hline
Caracteres intercambiados & \texttt{``hola''} → \texttt{``hloa''} \\ \hline
Múltiples errores & \texttt{``buenos días''} → \texttt{``buens dias''} \\ \hline
Espacios extra & \texttt{``hola\_''} \texttt{``\_ ayuda''} \\ \hline
Puntuación extra & \texttt{``ayuda!!''}, \texttt{``¡ayuda!!''} \\ \hline
Mayúsculas aleatorias & \texttt{``HoLa''}, \texttt{``AyUdA''} \\ \hline
Variaciones de acentos & \texttt{``médico''} vs \texttt{``medico''} \\ \hline
\end{tabular}
\caption[Tipos de perturbación]{Tipos de perturbaciones lingüísticas y ejemplos representativos, elaboración propia.}
\end{table}

\textbf{Degradación gradual por severidad}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{3cm}|p{4cm}|p{5cm}|}
\hline
\textbf{Nivel} & \textbf{Ejemplo} & \textbf{Comportamiento esperado} \\ \hline
Leve & \texttt{``hila''} & Clasifica correctamente \\ \hline
Medio & \texttt{``hla''} & Clasifica o activa deletreo \\ \hline
Grave & \texttt{``hkka''} & Activa deletreo \\ \hline
\end{tabular}
\caption[Niveles de error]{Clasificación de severidad de errores y el comportamiento esperado, elaboración propia.}
\end{table}

\textbf{Casos realistas con Leet Speak (4+ tests)}
Normalización de \textit{Leet Speak} en deletreo

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{2cm}|p{3cm}|p{6cm}|}
\hline
\textbf{\textit{Leet Speak}} & \textbf{Normalización} & \textbf{Ejemplo} \\ \hline
4 & A & \texttt{``M4ri@''} → \texttt{``MARIA''} \\ \hline
3 & E & \texttt{``P3dro''} → \texttt{``PEDRO''} \\ \hline
1 & I & \texttt{``T1po''} → \texttt{``TIPO''} \\ \hline
0 & O & \texttt{``H0la''} → \texttt{``HOLA''} \\ \hline
@ & A & \texttt{``C@rlos''} → \texttt{``CARLOS''} \\ \hline
\$ & S & \texttt{``Ca\$a''} → \texttt{``CASA''} \\ \hline
\end{tabular}
\caption[Normalización de Leet Speak]{Equivalencias para normalización de texto en Leet Speak, elaboración propia.}
\end{table}

\textbf{Resultados}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{4cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Métrica} & \textbf{Valor} & \textbf{Objetivo} \\ \hline

Total tests E2E & 26 & 30+ \\ \hline
Tests exitosos & 26 (100\%) & >95\% \\ \hline
Escenarios completos & 8 & 6+ \\ \hline
Tipos de perturbaciones & 11 & 8+ \\ \hline
Casos de perturbación testeados & 50+ & 30+ \\ \hline
Success rate con perturbaciones & >95\% & >90\% \\ \hline
Tiempo de ejecución & $\sim$15s & <30s \\ \hline

\end{tabular}
\caption[Métricas generales]{Resultados generales de pruebas E2E, elaboración propia.}
\end{table}

\textbf{Fortalezas identificadas}
\begin{itemize}
    \item Tolerancia a typos: $>95\%$ de clasificación correcta.
    \item Normalización efectiva de ruido y puntuación.
    \item Degradación gradual y graceful ante errores severos.
    \item Manejo correcto de casos edge (nombres propios, leet speak).
\end{itemize}

{\large \noindent \textbf{Tests de rendimiento y carga}}\\
Validación de velocidad, eficiencia y escalabilidad del sistema.\\

\textbf{Benchmarks de latencia}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{4cm}|p{2cm}|p{2cm}|p{3cm}|}
\hline
\textbf{Operación} & \textbf{Media} & \textbf{P95} & \textbf{Objetivo} \\ \hline

\textit{Query} completa & 42ms & 68ms & <100ms (P95) \\ \hline
Generación de \textit{embedding} & 28ms & 45ms & <50ms \\ \hline
Cache hit & 3ms & 6ms & <10ms \\ \hline
Preprocesamiento & 0.8ms & 1.5ms & <5ms \\ \hline
Cálculo similitud & 9ms & 15ms & <20ms \\ \hline

\end{tabular}
\caption[Latencias por operación]{Medición de latencias promedio y P95, elaboración propia.}
\end{table}

\textbf{Throughput medido}
\begin{itemize}
    \item Single query: $\sim 23$ q/s.
    \item Batch processing: $\sim 65$ q/s.
    \item Cache hit: $\sim 333$ q/s.
\end{itemize}

\textbf{Test de concurrencia}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{4cm}|p{2cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Test} & \textbf{Usuarios} & \textbf{Success rate} & \textbf{Latencia P95} \\ \hline

\textit{Concurrent 10 users} & 10 & 99.5\% & 78ms \\ \hline
\textit{Concurrent 50 users} & 50 & 98.3\% & 156ms \\ \hline
\textit{Concurrent 100 users} & 100 & 95.8\% & 287ms \\ \hline
\textit{Spike 0→20 users} & 20 & 96.2\% & 198ms \\ \hline
\textit{Soak 5 min} & 5 & 99.8\% & 82ms \\ \hline

\end{tabular}
\caption[Pruebas de carga]{Resultados de pruebas de concurrencia y resistencia, elaboración propia.}
\end{table}

\textbf{\textit{Load Testing} con Locust (50 usuarios, 5 minutos)}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{4cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Métrica} & \textbf{Valor} & \textbf{Objetivo} \\ \hline

Total requests & 8,742 & - \\ \hline
Requests/segundo (RPS) & 29.14 & >20 \\ \hline
Failures & 0.26\% & <1\% \\ \hline
Success rate & 99.74\% & >95\% \\ \hline
Latencia promedio & 52ms & <100ms \\ \hline
Latencia P95 & 118ms & <200ms \\ \hline
Latencia P99 & 187ms & <500ms \\ \hline

\end{tabular}
\caption[Métricas de rendimiento]{Resumen de rendimiento total, elaboración propia.}
\end{table}

\textbf{Resumen de métricas de rendimiento}
\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{3.2cm}|p{2.6cm}|p{2.6cm}|p{3cm}|}
\hline
\textbf{Métrica} & \textbf{Objetivo} & \textbf{Resultado} & \textbf{Cumplimiento} \\ \hline

Latencia P50 & <100ms & $\sim$42ms & 58\% mejor \\ \hline
Latencia P95 & <200ms & $\sim$68ms & 66\% mejor \\ \hline
Latencia P99 & <500ms & $\sim$134ms & 73\% mejor \\ \hline
\textit{Success Rate} & >95\% & 99.7\% & Excede \\ \hline
\textit{Throughput} & >50 q/s & $\sim$65 q/s & 30\% mejor \\ \hline
\textit{Max Users} & 100 & 100 & Cumple \\ \hline
\textit{Memory Growth} & <10\%/hour & <5\%/hour & 50\% mejor \\ \hline

\end{tabular}
\caption[Métricas de rendimiento]{Resumen de métricas de rendimiento, elaboración propia.}
\end{table}

{\large \noindent \textbf{Calidad semántica y métricas de PLN}}\\

Validación con metodologías específicas para sistemas de Procesamiento de Lenguaje Natural.\\

\noindent \textbf{Golden Dataset Testing}\\
Dataset curado manualmente con casos que deben funcionar correctamente\\

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{3.5cm}|p{2cm}|p{3cm}|p{4cm}|}
\hline
\textbf{Categoría} & \textbf{Casos} & \textbf{Min Similitud} & \textbf{Ejemplo} \\ \hline

\textit{Exact match} & 3 & >0.90 & ``Buenos días'' \\ \hline
\textit{Semantic variation} & 3 & >0.75 & ``necesito ayuda'' \\ \hline
\textit{Synonyms} & 6 & >0.65 & ``socorro'' \\ \hline
\textit{Noisy input} & 3 & >0.70 & ``hola!!'' \\ \hline
\textit{Typos} & 2 & >0.50 & ``hla'' \\ \hline

\textbf{Total} & 17 & - & - \\ \hline

\end{tabular}
\caption[Evaluación lingüística]{Resumen de evaluación lingüística, elaboración propia.}
\end{table}

\textbf{Resultado}: $100\%$ de golden dataset passing\\

\textbf{Métricas de clasificación semántica}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{3.5cm}|p{4cm}|p{2.5cm}|p{2.5cm}|}
\hline
\textbf{Métrica} & \textbf{Fórmula} & \textbf{Valor} & \textbf{Objetivo} \\ \hline

\textit{Precision} & TP/(TP+FP) & $\sim$89\% & >85\% \\ \hline
\textit{Recall} & TP/(TP+FN) & $\sim$87\% & >80\% \\ \hline
\textit{F1-Score} & $2 \cdot P \cdot R / (P + R)$ & $\sim$88\% & >82\% \\ \hline
\textit{Accuracy} & (TP+TN)/Total & $\sim$96\% & >90\% \\ \hline
\textit{Golden Dataset} & Correct/Total & 100\% & 100\% \\ \hline

\end{tabular}
\caption[Métricas de clasificación]{Resumen de métricas de clasificación, elaboración propia.}
\end{table}

El \textit{F1-Score} de 88\% indica balance óptimo entre \textit{precision} y \textit{recall}.\\

\textbf{Reconocimiento de sinónimos}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{2cm}|p{6cm}|p{2.5cm}|}
\hline
\textbf{Grupo} & \textbf{Sinónimos testeados} & \textbf{Accuracy} \\ \hline

A & ayuda, asistencia, socorro & 75\% \\ \hline
B & hola, saludos, buenos días & 80\% \\ \hline
C & gracias, muchas gracias, bien & 78\% \\ \hline

\end{tabular}
\caption[Sinónimos testeados]{Evaluación por grupos de sinónimos, elaboración propia.}
\end{table}

\textbf{Objetivo}: >70\% dentro de cada grupo.\\

\vspace{1em}

{\large \noindent \textbf{Cobertura de código}}\\
\textbf{Cobertura global del módulo}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{5cm}|p{1.8cm}|p{1.8cm}|p{2.2cm}|p{2.2cm}|}
\hline
\textbf{Módulo} & \textbf{Stmts} & \textbf{Missing} & \textbf{Coverage} & \textbf{Branch} \\ \hline

app/matcher\_improved.py & 445 & 38 & 91.5\% & 88.7\% \\ \hline
app/preprocess.py & 178 & 15 & 91.6\% & 89.2\% \\ \hline
app/main.py & 156 & 19 & 87.8\% & 82.1\% \\ \hline
app/models.py & 67 & 4 & 94.0\% & 91.5\% \\ \hline
app/config.py & 45 & 6 & 86.7\% & 83.3\% \\ \hline

\textbf{Total} & 891 & 82 & 90.8\% & 87.0\% \\ \hline

\end{tabular}
\caption[Coverage por módulo]{Resumen de coverage por módulo, elaboración propia.}
\end{table}

\textbf{Statement Coverage}: $90.8\%$ \ (Objetivo: $>80\%$)\\
\indent \textbf{Branch Coverage}: $87.0\%$ \ (Objetivo: $>75\%$)\\

\noindent \textbf{Análisis de líneas sin cobertura}\\
Las 82 líneas sin cobertura (9.2\%) corresponden a:\\

\begin{enumerate}
    \item Manejo de errores raros (35 líneas): Modelo no cargado, embeddings corruptos, errores de memoria.
    \item Logging y debugging (28 líneas): Logs de nivel DEBUG, telemetría.
    \item Código de infraestructura (19 líneas): Shutdown handlers, configuración avanzada.
\end{enumerate}

Estos casos no afectan la funcionalidad core del sistema.

%==================================================================================================

\section{Pruebas de Funcionamiento y Casos de Uso de la Aplicación}

\subsection{Estrategia de Pruebas}
Se debe realizar una prueba funcional de caja negra enfocada en los flujos críticos de la aplicación (validación, concatenación y control de reproducción).

\subsection{Casos de Prueba Críticos}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{1.7cm}|p{5cm}|p{5cm}|}
\hline
\textbf{ID} & \textbf{Acción del Usuario} & \textbf{Resultado Esperado} \\ \hline

\textbf{CP-1} & Ingresar ``hola'' & Secuencia [INICIO, Vídeo ``hola'', FIN]. \\ \hline

\textbf{CP-2} & Ingresar ``mi nombre es+Ivan'' & Secuencia [INICIO, Video ``me llamo'', ESPACIO, ``I``, ``V``, ``A``, ``N``, FIN]. \\ \hline

\textbf{CP-3} & Ingresar ``test!'' & Muestra mensaje de error. \\ \hline

\textbf{CP-4} & Ingresar ``texto'' y Pausar & El video se detiene y el índice no cambia. \\ \hline

\textbf{CP-5} & Secuencia en curso y Reiniciar & Inicia inmediatamente la reproducción desde \texttt{SIGNAL\_INICIO}. \\ \hline

\textbf{CP-6} & Errores ortográficos & Asignar la frase correcta. \\ \hline

\textbf{CP-7} & Campo vacío & Mensaje de error. \\ \hline

\end{tabular}
\caption[Casos de Prueba para la Lógica de SingAI]{Casos de Prueba para la Lógica de SingAI, elaboración propia.}
\end{table}

\newpage
\textbf{CP-1}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{Images/Cap4/images/hola.png}
    \caption{Captura del funcionamiento para el CP-1 (elaboración propia). Es posible observar que la salida deseada "hola" se cumplió}
    \label{fig:CP_1}
\end{figure}

\newpage
\textbf{CP-2}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{Images/Cap4/images/ivan.png}
    \caption{Captura del funcionamiento para el CP-2 (elaboración propia). En esta prueba se aprecia que se concatenó de forma correcta y se creó el arreglo de los videos.}
    \label{fig:CP_2}
\end{figure}

\newpage
\textbf{CP-3}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{Images/Cap4/images/test!.png}
    \caption{Captura del funcionamiento para el CP-3 (elaboración propia). Se puede observar que se le indico al usuario que está ingresando un caracter no permitido.}
    \label{fig:CP_3}
\end{figure}

\newpage
\textbf{CP-4}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{Images/Cap4/images/texto.png}
    \caption{Captura del funcionamiento para el CP-4 (elaboración propia). Se puede apreciar que se detuvo la secuencia en el índice 3 ya que se refleja en el cambio de icono del botón de pausa.}
    \label{fig:CP_4}
\end{figure}

\newpage
\textbf{CP-5}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{Images/Cap4/images/reinicio.png}
    \caption{Captura del funcionamiento para el CP-5 (elaboración propia). Partiendo de la frase anterior se oprimió el botón de reinicio lo que llevó a reiniciar la secuencia de videos.}
    \label{fig:CP_5}
\end{figure}

\newpage
\textbf{CP-6}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{Images/Cap4/images/errores.png}
    \caption{Captura del funcionamiento para el CP-6 (elaboración propia). En está prueba se puede observar tanto el manejo de los espacios como el módulo de PLN siendo exitoso en ambas consultas con errores ortográficos.}
    \label{fig:CP_6}
\end{figure}

\newpage
\textbf{CP-7}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{Images/Cap4/images/vacio.jpeg}
    \caption{Captura del funcionamiento para el CP-7 (elaboración propia), donde manda mensaje de error si el usuario ingresa un campo vacío.}
    \label{fig:CP_7}
\end{figure}

\newpage
La implementación de la aplicación \textbf{SignAI} ha demostrado ser exitosa, cumpliendo con todos los objetivos y reglas de negocio planteadas. La arquitectura diseñada, basada en la separación de responsabilidades entre el Frontend de \textbf{React Native/Expo}, el Backend de \textbf{FastAPI (PLN)} y el almacenamiento en \textbf{Amazon S3} garantiza un sistema modular, escalable y mantenible.

\subsection{Cumplimiento de los requerimientos funcionales}
\begin{itemize}
    \item \textbf{Editar texto}: el usuario en todo momento puede editar el texto ingresado, cumpliendo con el requerimiento funcional RF01.
    \item \textbf{Traducción Semántica Robusta}: se validó el funcionamiento del módulo de PLN (pruebas \ref{fig:CP_1} y \ref{fig:CP_6}), demostrando la capacidad del sistema para interpretar intenciones, manejar errores ortográficos y asignar la frase de LSM más adecuada, manteniendo la integridad de la traducción, lo que cumple con el requerimiento funcional RF02.
    \item \textbf{Representaciones visuales de las señas correspondientes}: se muestra que los videos de las señas correspondientes expresan movimientos coorporales y expersiones faciales(pruebas \ref{fig:CP_1}, \ref{fig:CP_2}, \ref{fig:CP_4}, \ref{fig:CP_5}), esto cumple con el requerimiento funcional RF03.
    \item \textbf{Modo de deletreo}: en las pruebas \ref{fig:CP_2} y \ref{fig:CP_4} podemos observar como se activa y se asigna el modo de deletreo para cada letra del texto ingresada ya que el sistema no encontró una frase con similitud.
\end{itemize}


\subsection{Adherencia a las Reglas de Negocio}
La aplicación respeta estrictamente las reglas de negocio críticas para la experiencia del usuario y la seguridad del sistema:

\begin{itemize}
    \item \textbf{RN01 (Entrada manual)}: la aplicación solo permite al usuario ingresar el texto de forma manual.
    \item \textbf{RN02 (Límite de caracteres)}: se le asignó un límite de caracteres.
    \item \textbf{RN03 (Restricción de Entrada)}: la validación de entrada \texttt{validarTexto} asegura que solo caracteres traducibles (letras y espacio) entren al sistema.
    \item \textbf{RN04 (Activación de botón "traducir")}: si el usuario ingresa un campo vacío la aplicación manda un mensaje
    \item \textbf{RN05 y RN06 (Manejo de Caracteres Inválidos)}: si se detecta un carácter no permitido, el sistema detiene el proceso de traducción y emite un mensaje de error claro al usuario, indicando el carácter específico que debe ser removido (prueba \ref{fig:CP_3}).
    \item \textbf{RN07(Siempre mostrar animación)}: el sistema garantiza siempre darle una respuesta al usuario aunque no encuentre similitud de alguna frase.
\end{itemize}

\textbf{SignAI} es un producto funcional y estable. La documentación técnica y la evidencia de las pruebas demuestran que el sistema está listo para el despliegue final, brindando una solución eficaz y confiable para la traducción de texto a Lengua de Señas Mexicana.

\subsection{Video de funcionamiento}
\url{https://drive.google.com/file/d/1lu_suRxC8Mf-s6DCtPHaD5JmAzrJgjEW/view?usp=sharing}

\subsection{Código fuente de la app}

\begin{lstlisting}   
import React, { useState, useCallback, useEffect } from "react";
import { View, Text, TextInput, Button, StyleSheet, ActivityIndicator, Alert, TouchableOpacity } from "react-native";
import { VideoView, useVideoPlayer } from "expo-video";
import { MaterialIcons } from "@expo/vector-icons"; 

interface RespuestaAPI {
  query: string;
  grupo: string | null;
  frase_similar: string;
  similitud: number;
  deletreo_activado: boolean;
  deletreo: string[] | null;
  total_caracteres: number | null;
  url_video: string;
  spell_urls: string[] | null;
}

const API_URL = "http://192.168.0.159:8000/buscar";


const SIGNAL_MARKERS = {
  inicio: "SIGNAL_INICIO",
  fin: "SIGNAL_FIN",
  espacio: "SIGNAL_ESPACIO" 
};


const CARACTERES_NO_PERMITIDOS = [
  '.', ',', ';', ':', '!', '-', '_', '@', '#', '$', '%', '&', "'", '"',
  '/', '\\', '(', ')', '[', ']', '{', '}', '=', '*', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
];

const NOMBRES_CARACTERES: { [key: string]: string } = {
  '.': 'punto',
  ',': 'coma',
  ';': 'punto y coma',
  ':': 'dos puntos',
  '!': 'exclamación',
  '?': 'interrogación',
  '-': 'guión',
  '_': 'guión bajo',
  '@': 'arroba',
  '#': 'numeral',
  '$': 'dólar',
  '%': 'porcentaje',
  '&': 'ampersand',
  '/': 'barra',
  '\\': 'barra invertida',
  '(': 'paréntesis abierto',
  ')': 'paréntesis cerrado',
  '[': 'corchete abierto',
  ']': 'corchete cerrado',
  '{': 'llave abierta',
  '}': 'llave cerrada',
  '+': 'más',
  '=': 'igual',
  '*': 'asterisco',
  '"': 'comillas',
  "'": 'comilla simple'
};
export default function Index() {
  const [texto, setTexto] = useState("");
  const [respuesta, setRespuesta] = useState<RespuestaAPI | null>(null);
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [errorValidacion, setErrorValidacion] = useState<{ caracter: string, nombre: string } | null>(null);
  
  
  const [indiceLetraActual, setIndiceLetraActual] = useState(0);
  const [videoActual, setVideoActual] = useState<string | null>(null);
  const [secuenciaCompleta, setSecuenciaCompleta] = useState<string[]>([]);
  const [enPausa, setEnPausa] = useState(false);
  const [pausadoPorUsuario, setPausadoPorUsuario] = useState(false);
  const [deletreoInfo, setDeletreoInfo] = useState<string[]>([]);
  
  
  const mostrarAyuda = () => {
  Alert.alert(
    "¿CÓMO FUNCIONA SignAI?",
    `
ESTRUCTURA DE LA TRADUCCIÓN:

1. ENTRADA DE TEXTO:
   - Solo se permiten LETRAS y ESPACIOS.
   - Usa el símbolo '+' para CONCATENAR varias frases en una sola secuencia (Ej: mi nombre es+Juan).

2. CARACTERES NO PERMITIDOS:
   - Los números y la mayoría de los SÍMBOLOS (.,;:-_@#$...) serán RECHAZADOS.

3. FLUJO DE REPRODUCCIÓN SECUENCIAL:
   - INICIO: La secuencia comienza con la señal AMARILLA (INICIO).
   - FIN: La secuencia termina con la señal AZUL (FIN).
   - ESPACIOS: Los espacios se representan con la señal VERDE [ _ ].

4. CONTROLES:
   - Los botones PAUSA/PLAY y REINICIO aparecen debajo del reproductor para controlar la secuencia.
    `,
    [{ text: "ENTENDIDO" }]
  );
};
  
  
  const reiniciarApp = useCallback(() => {
    setTexto("");
    setRespuesta(null);
    setCargando(false);
    setError(null);
    setErrorValidacion(null);
    setIndiceLetraActual(0);
    setVideoActual(null);
    setSecuenciaCompleta([]);
    setEnPausa(false);
    setPausadoPorUsuario(false);
    setDeletreoInfo([]);
  }, []);

  
  const avanzarSecuencia = useCallback(() => {
    
    
    setIndiceLetraActual(prevIndice => {
        const siguienteIndice = prevIndice + 1;
        const totalElementos = secuenciaCompleta.length; 

        
        if (siguienteIndice < totalElementos) {
            
            setEnPausa(true);
            setTimeout(() => {
                setVideoActual(secuenciaCompleta
                [siguienteIndice]);
                setEnPausa(false);
            }, 1000);
        } else {
            
            setEnPausa(true);
            setTimeout(() => {
                setVideoActual(secuenciaCompleta[0]);
                setIndiceLetraActual(0); 
                setEnPausa(false);
            }, 1000); 
            return 0; 
        }
        
        return siguienteIndice; 
    });
  }, [secuenciaCompleta]);

  const reiniciarReproduccion = useCallback(() => {
    if (secuenciaCompleta.length > 0) {
      setPausadoPorUsuario(false); 
      setIndiceLetraActual(0);
      setVideoActual(secuenciaCompleta[0]);
      setEnPausa(false);
      
    }
  }, [secuenciaCompleta]);

  
  const validarTexto = (texto: string): { valido: boolean; caracterInvalido?: string; nombreCaracter?: string } => {
    
    const textoSinMas = texto.replace(/\+/g, '');
    
    for (const char of textoSinMas) {
      if (CARACTERES_NO_PERMITIDOS.includes(char)) {
        return {
          valido: false,
          caracterInvalido: char,
          nombreCaracter: NOMBRES_CARACTERES[char] || 'número'
        };
      }
    }
    return { valido: true };
  };

  
  const procesarMultiplesFrases = async (textoCompleto: string): Promise<{
    secuencia: string[],
    deletreoInfo: string[]
  }> => {
    const frases = textoCompleto.split('+').map(f => f.trim()).filter(f => f.length > 0);
    
    let secuenciaFinal: string[] = [];
    let deletreoInfoFinal: string[] = [];

    for (const frase of frases) {
      try {
        const response = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ texto: frase }),
        });

        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status}`);
        }

        const data: RespuestaAPI = await response.json();

        if (data.deletreo_activado && data.spell_urls && data.spell_urls.length > 0) {
          
          const urlsProcesadas = data.spell_urls.map((url, index) => {
            const deletreado = data.deletreo || [];
            
            
            if (deletreado[index] === "espacio" && url === "") {
                return SIGNAL_MARKERS.espacio;
            }
            
            return url;
          });
          
          secuenciaFinal.push(...urlsProcesadas);
          
          
          if (data.deletreo) {
            deletreoInfoFinal.push(...data.deletreo);
          }
        } else if (data.url_video) {
          
          secuenciaFinal.push(data.url_video);
          deletreoInfoFinal.push(data.frase_similar);
        }
      } catch (err) {
        console.error(`Error al procesar frase "${frase}":`, err);
        throw err;
      }
      
      
      if (secuenciaFinal.length > 0 && frase !== frases[frases.length - 1]) {
        secuenciaFinal.push(SIGNAL_MARKERS.espacio);
        deletreoInfoFinal.push("espacio");
      }
    }

    return { secuencia: secuenciaFinal, deletreoInfo: deletreoInfoFinal };
  };

  const traducir = useCallback(async () => {
    setErrorValidacion(null);
    if (!texto.trim()) {
      Alert.alert("Error", "Por favor, ingresa una palabra o frase para traducir.");
      return;
    }

    
    const validacion = validarTexto(texto);
    if (!validacion.valido) {
      setErrorValidacion({
        caracter: validacion.caracterInvalido!,
        nombre: validacion.nombreCaracter!,
      });
      setRespuesta(null);
      setCargando(false);
      setError(null);
      return;
    }

    setCargando(true);
    setRespuesta(null);
    setError(null);
    setIndiceLetraActual(0);
    setVideoActual(null);
    setSecuenciaCompleta([]);
    setEnPausa(false);
    setPausadoPorUsuario(false);
    setDeletreoInfo([]);

    try {
      console.log(`Intentando conectar a: ${API_URL}`);
      
      
      const { secuencia, deletreoInfo } = await procesarMultiplesFrases(texto);
      
      if (secuencia.length === 0) {
           setError("No se pudo obtener la secuencia de videos. La respuesta de la API fue vacía.");
           return;
      }

      
      const secuenciaConSenales = [
        SIGNAL_MARKERS.inicio,
        ...secuencia,
        SIGNAL_MARKERS.fin
      ];

      setSecuenciaCompleta(secuenciaConSenales);
      setDeletreoInfo(deletreoInfo);
      setVideoActual(secuenciaConSenales[0]);
      setIndiceLetraActual(0);

      
      setRespuesta({
        query: texto,
        grupo: null,
        frase_similar: deletreoInfo.join(" "),
        similitud: 1.0,
        deletreo_activado: true, 
        deletreo: deletreoInfo,
        total_caracteres: deletreoInfo.length,
        url_video: "",
        spell_urls: secuencia
      });

    } catch (err) {
      console.error("Error al conectar con la API:", err);
      const errorMessage = `No se pudo contactar al servidor. Detalle: ${(err as Error).message}`;
      setError(errorMessage);
      Alert.alert("Error de Conexión", errorMessage);
      setRespuesta(null);
    } finally {
      setCargando(false);
    }
  }, [texto]);

  
  const togglePausa = () => {
    setPausadoPorUsuario(prev => !prev);
  };

  
  const esSenal = videoActual === SIGNAL_MARKERS.inicio || 
                  videoActual === SIGNAL_MARKERS.fin || 
                  videoActual === SIGNAL_MARKERS.espacio;

  const player = useVideoPlayer(
    videoActual && !esSenal ? { uri: videoActual } : null,
    (player) => {
      if (player) {
        player.loop = false;
        player.muted = true;
        
        if (!pausadoPorUsuario) {
          player.play();
        }
      }
    }
  );

  
  useEffect(() => {
    
    if (pausadoPorUsuario) {
      player?.pause();
      return;
    }

    
    if (!videoActual || enPausa) return;

    
    if (esSenal) {
      const duracion = videoActual === SIGNAL_MARKERS.espacio ? 800 : 2000;
      
      const timer = setTimeout(avanzarSecuencia, duracion);
      return () => clearTimeout(timer);
    }

    
    if (!player) return;

    
    player.replace({ uri: videoActual });
    if (!player.playing) {
        player.play();
    }
    
    
    const subscription = player.addListener('playingChange', (newStatus) => {
        
        
        if (newStatus.isPlaying === false && !pausadoPorUsuario) {
             avanzarSecuencia(); 
        }
    });

    return () => {
      subscription.remove();
    };
  }, [videoActual, pausadoPorUsuario, esSenal, player, avanzarSecuencia, enPausa]);


  
  


  const obtenerEstadoReproduccion = () => {
    if (secuenciaCompleta.length === 0) {
      return "";
    }

    
    if (indiceLetraActual === 0) {
      return "SEÑAL DE INICIO";
    }

    
    if (indiceLetraActual === secuenciaCompleta.length - 1) {
      return "SEÑAL DE FIN";
    }

    
    const indiceReal = indiceLetraActual - 1;

    
    const elementoActual = deletreoInfo[indiceReal];

    if (videoActual === SIGNAL_MARKERS.espacio || elementoActual === "espacio") {
      return `Elemento ${indiceReal + 1} de ${deletreoInfo.length}: [espacio]`;
    }

    if (deletreoInfo && indiceReal >= 0 && indiceReal < deletreoInfo.length) {
      return `Elemento ${indiceReal + 1} de ${deletreoInfo.length}: ${elementoActual}`;
    }

    return "";
  };

  
  const VideoControls = () => {
    const mostrarControles = secuenciaCompleta.length > 0;

    if (!mostrarControles) {
      return null;
    }

    return (
      <View style={styles.controlsContainer}>
        {/* Botón de Pausa / Reanudar */}
        <TouchableOpacity
          style={[styles.controlButton, pausadoPorUsuario && styles.controlButtonActive]}
          onPress={togglePausa}
        >
          <MaterialIcons
            name={pausadoPorUsuario ? "play-arrow" : "pause"}
            size={24}
            color="white"
          />
        </TouchableOpacity>

        {/* Botón de Reiniciar Secuencia */}
        <TouchableOpacity
          style={[styles.controlButton, styles.controlButtonRestart]}
          onPress={reiniciarReproduccion}
        >
          <MaterialIcons
            name="restart-alt"
            size={24}
            color="white"
          />
        </TouchableOpacity>
      </View>
    );
  }

  const RespuestaResultado = () => {
    if (respuesta) {
      const titulo = respuesta.deletreo_activado
        ? "Traducción en Progreso"
        : `Frase Sugerida (${respuesta.grupo})`;

      const fraseMostrada = respuesta.frase_similar;

      return (
        <View style={styles.resultBox}>
          <Text style={styles.resultText}>
            {titulo}: {fraseMostrada}
          </Text>

          {respuesta.deletreo_activado && respuesta.deletreo && (
            <>
              <Text style={styles.similarityText}>
                Secuencia: {respuesta.deletreo.join(", ")}
              </Text>
              <Text style={styles.progressText}>
                {obtenerEstadoReproduccion()}
              </Text>

            </>
          )}

          {!respuesta.deletreo_activado && (
            <Text style={styles.infoText}>
              El video se repetirá automáticamente
            </Text>
          )}
        </View>
      );
    }
    return null;
  };

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerText}>SignAI <MaterialIcons name="waving-hand" size={24} color="#000000ff" /></Text>
      </View>

      {/* Contenido principal */}
      <View style={styles.animationBox}>

        {/* Botones de Ayuda y Reinicio de App */}
        <View style={styles.overlayButtons}>
          {/* Botón de Pista/Ayuda (Esquina Superior Izquierda) */}
          <TouchableOpacity
            style={[styles.utilityButton, styles.helpButton]}
            onPress={mostrarAyuda}
            disabled={cargando}
          >
            <MaterialIcons name="emoji-objects" size={24} color="#000000ff" />
          </TouchableOpacity>

          {/* Botón de Reinicio de App (Esquina Superior Derecha) */}
          <TouchableOpacity
            style={[styles.utilityButton, styles.homeButton]}
            onPress={reiniciarApp}
            disabled={cargando}
          >
            <MaterialIcons name="stop-circle" size={24} color="#000" />
          </TouchableOpacity>
        </View>
        {/* -------------------------------------- */}

        {cargando ? (
          <ActivityIndicator size="large" color="#FFD700" />
        ) : errorValidacion ? (
          <View style={[styles.videoPlayer, styles.errorValidationContainer]}>
            <Text style={styles.errorValidationTitle}> Carácter No Permitido </Text>
            <Text style={styles.errorValidationText}>
              {`El carácter "${errorValidacion.caracter}" (${errorValidacion.nombre}) no está permitido.`}
            </Text>
            <Text style={styles.errorValidationSubtitle}>
              Solo se permiten letras, espacios y el símbolo + para concatenar frases.
            </Text>
          </View>
        ) : videoActual === SIGNAL_MARKERS.inicio ? (
          <View style={styles.videoPlayer}>
            <View style={styles.signalContainer}>
              <View style={[styles.signalCircle, styles.signalInicio]}>
                <Text style={styles.signalText}>INICIO</Text>
              </View>
            </View>
          </View>
        ) : videoActual === SIGNAL_MARKERS.fin ? (
          <View style={styles.videoPlayer}>
            <View style={styles.signalContainer}>
              <View style={[styles.signalCircle, styles.signalFin]}>
                <Text style={styles.signalText}>FIN</Text>
              </View>
            </View>
          </View>
        ) : videoActual === SIGNAL_MARKERS.espacio ? (
          <View style={styles.videoPlayer}>
            <View style={styles.signalContainer}>
              <View style={[styles.signalCircle, styles.signalEspacio]}>
                <Text style={styles.signalText}>[ _ ]</Text>
              </View>
            </View>
          </View>
        ) : videoActual ? (
          <VideoView
            style={styles.videoPlayer}
            player={player}
            nativeControls={false}
          />
        ) : (
  <View style={styles.videoPlayer}>
    <View style={styles.welcomeContainer}>
      
      {/* 1. Icono de Saludo Grande (MaterialIcons: waving-hand o similar) */}
      <Text style={styles.welcomeText}></Text>
      {/* <MaterialIcons name="waving-hand" size={90} color="#000000ff" style={styles.wavingHand} /> */}

      {/* 2. Nombre de la Aplicación en Grande */}
      <Text style={styles.welcomeText}>SignAI</Text>

      {/* 3. Subtítulo opcional (opcional, para dar contexto) */}
      <Text style={styles.subtitleText}>
        Ingresa una frase para ver la traducción en LSM
      </Text>
    </View>
  </View>
)}

        {/* Error visual */}
        {error && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTextTitle}>Error de Conexión:</Text>
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}
      </View>

      {/* Controles de Video */}
      <VideoControls />

      {/* Input y resultado */}
      <View style={styles.inputBox}>
        <TextInput
          style={styles.input}
          placeholder="Ingresa cualquier texto"
          placeholderTextColor="#A9A9A9"
          value={texto}
          onChangeText={setTexto}
          editable={!cargando}
        />
        <Button
          title={cargando ? "Cargando..." : "Traducir"}
          onPress={traducir}
          disabled={cargando}
        />
        <RespuestaResultado />
      </View>

      {/* Footer */}
      <View style={styles.footer}>
        <Text style={styles.footerText}>SignAI</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "white",
  },
  header: {
    backgroundColor: "#FFD700",
    padding: 20,
    alignItems: "center",
  },
  headerText: {
    fontSize: 20,
    fontWeight: "bold",
    color: "black",
  },
  animationBox: {
    flex: 3,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 20,
    backgroundColor: "#fff",
    width: "100%",
    
    position: 'relative',
  },
  
  overlayButtons: {
    position: 'absolute',
    top: 10,
    left: 10,
    right: 10,
    flexDirection: 'row',
    justifyContent: 'space-between',
    zIndex: 10, 
  },
  utilityButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: "#fff",
    justifyContent: "center",
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    borderColor: '#ccc',
    borderWidth: 1,
  },
  helpButton: {
    
  },
  homeButton: {
    
  },
  
  videoPlayer: {
    width: "100%",
    maxWidth: 360,
    aspectRatio: 1,
    alignSelf: "center",
    borderRadius: 10,
    backgroundColor: "#ffffffff",
    overflow: "hidden",
  },
  controlsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 10,
    backgroundColor: '#fff',
  },
  controlButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: "#007bff",
    justifyContent: "center",
    alignItems: "center",
    marginHorizontal: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  controlButtonActive: {
    backgroundColor: "#007bff", 
  },
  controlButtonRestart: {
    backgroundColor: "#007bff", 
  },
  controlButtonText: {
    color: "white",
    fontSize: 18,
    fontWeight: "bold",
  },
  inputBox: {
    flex: 2,
    padding: 20,
  },
  input: {
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 6,
    padding: 10,
    marginBottom: 10,
    backgroundColor: "white",
  },
  footer: {
    backgroundColor: "#FFD700",
    padding: 15,
    alignItems: "center",
  },
  footerText: {
    fontSize: 14,
    color: "black",
  },
  resultBox: {
    marginTop: 15,
    padding: 10,
    backgroundColor: "#eee",
    borderRadius: 8,
  },
  resultText: {
    fontSize: 16,
    fontWeight: "bold",
    color: "#333",
  },
  similarityText: {
    fontSize: 14,
    color: "gray",
    marginTop: 5,
  },
  progressText: {
    fontSize: 14,
    color: "#007bff",
    marginTop: 5,
    fontWeight: "600",
  },
  infoText: {
    fontSize: 12,
    color: "#666",
    marginTop: 5,
    fontStyle: "italic",
  },
  errorBox: {
    marginTop: 10,
    padding: 10,
    backgroundColor: "#fee2e2",
    borderColor: "#f87171",
    borderWidth: 1,
    borderRadius: 8,
    width: "100%",
    maxWidth: 350,
  },
  errorTextTitle: {
    fontWeight: "bold",
    color: "#b91c1c",
    marginBottom: 4,
  },
  errorText: {
    fontSize: 12,
    color: "#b91c1c",
  },
  signalContainer: {
    width: "100%",
    height: "100%",
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#ffffff",
    borderRadius: 10,
  },
  signalCircle: {
    width: 200,
    height: 200,
    borderRadius: 100,
    justifyContent: "center",
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
    elevation: 8,
  },
  signalInicio: {
    backgroundColor: "#FFD700",
  },
  signalFin: {
    backgroundColor: "#4169E1",
  },
  signalEspacio: {
    backgroundColor: "#000000ff",
  },
  signalText: {
    fontSize: 32,
    fontWeight: "bold",
    color: "white",
    textShadowColor: "rgba(0, 0, 0, 0.3)",
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 3,
  },
  errorValidationContainer: {
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#ffe0e0",
    padding: 20,
    borderWidth: 2,
    borderColor: "#e53e3e",
    width: "70%",
  },
  errorValidationTitle: {
    fontSize: 18,
    fontWeight: "bold",
    color: "#e53e3e",
    marginBottom: 10,
    textAlign: "center",
  },
  errorValidationText: {
    fontSize: 16,
    color: "#333",
    marginBottom: 5,
    textAlign: "center",
  },
  errorValidationSubtitle: {
    fontSize: 14,
    color: "#666",
    marginTop: 10,
    textAlign: "center",
    fontStyle: "italic",
  },

  



welcomeContainer: {
  flex: 1,
  justifyContent: 'center',
  alignItems: 'center',
  backgroundColor: '#fff',
  width: '100%',
},
welcomeText: {
  fontSize: 48,
  fontWeight: 'bold',
  color: '#000000ff', 
  textAlign: 'center',
  marginTop: 10,
},
subtitleText: {
  fontSize: 16,
  color: 'gray',
  marginTop: 10,
},
wavingHand: {
  
  transform: [{ rotate: '20deg' }], 
},
emojiText: {
  fontSize: 90, 
  textAlign: 'center',
},
});
\end{lstlisting}

\subsection{Configuración de Dependencias: \texttt{package.json}}
El siguiente listado muestra las dependencias y versiones exactas del proyecto, esenciales para asegurar la reproducibilidad del entorno de compilación (SDK y librerías clave como \texttt{expo-video}).

\begin{lstlisting}
{
  "main": "expo-router/entry",
  "name": "mi-lsm-app",
  "version": "1.0.1",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "expo": "~50.0.14",
    "expo-status-bar": "~1.11.1",
    "expo-router": "~3.4.8",
    "react": "18.2.0",
    "react-native": "0.73.6",
    "expo-video": "~5.2.0",
    "react-native-safe-area-context": "4.8.2",
    "react-native-screens": "~3.29.0",
    "expo-constants": "~15.4.6"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "~18.2.45",
    "typescript": "^5.1.3"
  },
  "private": true
}
\end{lstlisting}

\section{Despliegue de Producción}
\label{sec:despliegue}

\subsection{El Producto Final: APK y AAB}

Para distribuir la aplicación SignAI a usuarios de Android, el código fuente desarrollado en React Native/Expo debe ser compilado en un paquete binario ejecutable.

\begin{itemize}
    \item \textbf{APK (Android Package Kit):} Es el formato de archivo de paquete utilizado por el sistema operativo Android para la distribución e instalación de aplicaciones móviles. Esencialmente, contiene todos los elementos necesarios para que la aplicación se instale correctamente en un dispositivo \cite{refapp2}.
    \item \textbf{AAB (Android App Bundle):} Es el formato de publicación recomendado por Google Play Store. Un AAB es un paquete binario que incluye el código, los recursos y las librerías necesarios, pero difiere el proceso de generación del APK final al momento de la descarga. Google Play utiliza esta optimización (denominada \textit{Dynamic Delivery}) para crear un APK más pequeño y optimizado para el dispositivo específico del usuario \cite{refapp3}.
    \item \textbf{Herramienta de Compilación:} El proceso de generación de estos paquetes se realiza en la nube de Expo utilizando \textbf{EAS Build} (\textit{Expo Application Services}). Esto garantiza que el código fuente de React Native se traduzca de forma robusta a los binarios nativos de Android \cite{refapp4}.
\end{itemize}



\textbf{Definición de Microservicio en SignAI}\\
Un microservicio es una arquitectura donde las funcionalidades de una aplicación se dividen en servicios más pequeños, independientes y comunicables a través de protocolos de red \cite{refapp5}. En el contexto de SignAI:
\begin{itemize}
    \item La API de FastAPI es el \textbf{Servicio de Traducción}.
    \item Su única responsabilidad es procesar el texto, ejecutar el PLN, aplicar los umbrales de similitud y devolver la secuencia de URLs de video.
\end{itemize}
El despliegue en Render proporciona una \textbf{URL pública y estable}, reemplazando la dirección IP local que solo funcionaba en el entorno de desarrollo.\\

\vspace{0.7em}
\textbf{Microservicio: Despliegue de la API en Render}
\label{subsec:microservicio}

Para garantizar la accesibilidad y el funcionamiento continuo de la aplicación una vez compilada como APK o AAB, el Backend de \textbf{FastAPI (PLN)} se desplegará como un microservicio en una plataforma como \textbf{Render}.\\

\textbf{¿Qué es Render?}\\
\label{subsubsec:render_def}
Render es una plataforma moderna de nube unificada (\textit{Unified Cloud Platform}) que simplifica el despliegue y alojamiento de aplicaciones web, bases de datos y microservicios. A diferencia de proveedores de infraestructura tradicionales (como AWS o Azure), Render se enfoca en ofrecer una experiencia de desarrollo fluida, permitiendo a los desarrolladores centrarse en el código de la aplicación \cite{refapp6}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images/Cap4/images/render.jpg}
    \caption{Icono de Render}
    \label{fig:render}
\end{figure}

\textbf{Ventajas del Despliegue en Render}\\
\begin{enumerate}
    \item \textbf{Accesibilidad 24/7:} La API está disponible globalmente, permitiendo que el APK final funcione sin requerir que la laptop del desarrollador esté encendida o conectada a la misma red local \cite{refapp5}.
    \item \textbf{Separación Clara de Responsabilidades:} Se refuerza la arquitectura modular: el Frontend se encarga de la interfaz y la reproducción, y Render se encarga de la lógica de negocio y el PLN \cite{refapp5}.
    \item \textbf{Actualizaciones Transparentes:} Cualquier mejora en el módulo de PLN (ej., ajuste de umbrales, mejora del modelo) se realiza actualizando el código en Render. Esta mejora es instantánea para el usuario final del APK, sin necesidad de que descarguen una nueva versión de la aplicación \cite{refapp6}.
    \item \textbf{Escalabilidad:} Render ofrece la capacidad de escalar el servicio de FastAPI de forma independiente si la demanda del servicio de traducción aumenta, garantizando el rendimiento sin afectar la experiencia de usuario del cliente móvil \cite{refapp6}.
\end{enumerate}

\subsection{Integración Arquitectónica Final}

La comunicación entre el Frontend (APK) y el Backend (Render) se realiza mediante peticiones HTTP a la URL pública.\\

El proceso de comunicación es el siguiente:
\begin{enumerate}
    \item El usuario ingresa texto en el \textbf{APK}.
    \item El Frontend (\texttt{index.tsx}) envía la petición a \texttt{API\_URL} (\textbf{Render/FastAPI}).
    \item El Microservicio PLN procesa la entrada, accede a las bases de datos de frases y devuelve la secuencia de URLs (o URLs de deletreo).
    \item El Frontend consume la respuesta y utiliza las URLs de \textbf{AWS S3} para cargar los videos en la vista \texttt{VideoView}.
\end{enumerate}
Este flujo robusto garantiza que el objetivo de un producto listo para el usuario final se cumpla con alta disponibilidad y mantenimiento simplificado.


%===============================================================
%===============================================================
\section{Prueba de Usabilidad mediante Cuestionario Estructurado}

Con el propósito de evaluar la experiencia de uso, la percepción de calidad del módulo de traducción y la claridad de las animaciones en Lengua de Señas Mexicana (LSM), se aplicó una prueba de usabilidad basada en un cuestionario estructurado.\\

Este instrumento fue diseñado considerando las recomendaciones de la norma ISO 9241-210 \cite{ref62}, así como principios derivados de las heurísticas de Nielsen \cite{ref61}, con el fin de evaluar aspectos como:

\begin{itemize}
    \item Facilidad de uso.
    \item Pertinencia de la traducción.
    \item Calidad perceptual del movimiento de la animación.
    \item Utilidad del vocabulario incluido.
    \item satisfacción general del usuario.
\end{itemize}

\noindent \textbf{Procedimiento}\\
La prueba se llevó a cabo siguiendo el siguiente protocolo:
\begin{itemize}
    \item A cada participante se le mostró un video demostrativo del funcionamiento de la aplicación.
    \item Posteriormente, se le invitó a responder un cuestionario en línea compuesto por preguntas cerradas de opción múltiple, escalas Likert de 1 a 5 \cite{refpru1}, y preguntas abiertas para permitir observaciones cualitativas.
    \item La participación fue anónima y sin recopilar datos personales sensibles.
    \item No se requirió experiencia previa en LSM para participar.
\end{itemize}

\noindent \textbf{Estructura del cuestionario}\\
El cuestionario se compone de cinco bloques temáticos:
\begin{itemize}
    \item Datos demográficos.
    \item Conocimientos previos en LSM.
    \item Percepción de velocidad y pertinencia de la traducción.
    \item Calidad del movimiento del avatar.
    \item Cubrimiento del vocabulario y opinión general.
\end{itemize}

En la \textbf{Tabla \ref{tab:instrumento-usabilidad}} se resume la estructura completa del instrumento, indicando el tipo de pregunta y su propósito.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|p{5cm}|p{4cm}|p{4cm}|}
\hline
\textbf{Categoría} & \textbf{Pregunta evaluada} & \textbf{Tipo de respuesta} \\ \hline

Datos demográficos & Edad del participante & Opción múltiple \\ \hline

Conocimientos previos en LSM & Nivel de dominio de LSM & Opción múltiple \\ \hline

Experiencia previa & Uso previo de herramientas de traducción & Sí / No \\ \hline

Comparativa con herramientas previas & Diferencias observadas respecto a herramientas de traducción previamente utilizadas & Respuesta abierta \\ \hline

Velocidad y pertinencia de traducción & Evaluación de qué tan rápido y pertinente fue el emparejamiento de la frase (escala 1–5) & Escala Likert \\ \hline

Utilidad del deletreo & Utilidad del modo de deletreo dentro de una conversación & Escala Likert \\ \hline

Calidad del movimiento del avatar & Percepción de fluidez y claridad del movimiento en las animaciones & Opción múltiple \\ \hline

Cobertura del vocabulario & Adecuación del conjunto de frases y categorías incluidas en la aplicación & Opción múltiple \\ \hline

Fortalezas percibidas & Aspectos positivos o elementos destacados por el usuario & Respuesta abierta \\ \hline

Áreas de oportunidad & Problemas, fallas o aspectos a mejorar identificados por el usuario & Respuesta abierta \\ \hline

\end{tabular}
\caption[Instrumento de evaluación de usabilidad]{Resumen del cuestionario empleado para la evaluación de usabilidad de la aplicación, elaboración propia.}
\label{tab:instrumento-usabilidad}
\end{table}

Una copia íntegra del cuestionario, con el texto exacto de cada reactivo, se incluye en el \textbf{\nameref{anexo:cuestionario}} para referencia completa.
